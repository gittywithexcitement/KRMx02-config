loadusr -W hal_input X-Box

## pippin88's custom_postgui.hal file
## pippin88@imagineant.com
## customised for generic X-Box controller from Ebay
## Based on:
## http://wiki.linuxcnc.org/cgi-bin/wiki.pl?Simple_Remote_Pendant
## http://wiki.linuxcnc.org/cgi-bin/wiki.pl?Adding_More_Controls_To_Simple_Remote_Pendant
## need linuxcnc 2.5 or better

# values < 6000 become 0
setp input.0.abs-rx-flat 6000
setp input.0.abs-ry-flat 6000
setp input.0.abs-y-flat 6000

# invert z and y axis
setp input.0.abs-ry-scale -32767.5
setp input.0.abs-y-scale -32767.5

# Left trigger slows the jog speed down. Right trigger speeds up jog.
# X,Y,A,B buttons, while held, are incremental movement at varying speeds.
# Left joystick is Z, right joystick is X,Y
# Back button engages E stop.
# Start button turns E stop off, then turns machine on.

loadrt or2 	count=6
loadrt toggle 	count=1
loadrt near count=9
loadrt and2 count=6
loadrt mux2 count=3
loadrt mux4 count=1
loadrt mux8 count=1
loadrt not 	names=left-z-pressed,right-z-pressed
loadrt scale 		names=cont-jog-scale,decrease-z-speed
loadrt joyhandle 	names=slow-joy,fast-joy

addf or2.0 servo-thread
addf or2.1 servo-thread
addf or2.2 servo-thread
addf or2.3 servo-thread
addf or2.4 servo-thread
addf or2.5 servo-thread
addf mux8.0 servo-thread
addf toggle.0 servo-thread
addf mux2.0 servo-thread
addf mux2.1 servo-thread
addf mux2.2 servo-thread
addf mux4.0 servo-thread
addf near.0 servo-thread
addf near.1 servo-thread
addf near.2 servo-thread
addf near.3 servo-thread
addf near.4 servo-thread
addf near.5 servo-thread
addf near.6 servo-thread
addf near.7 servo-thread
addf near.8 servo-thread
addf and2.0 servo-thread
addf and2.1 servo-thread
addf and2.2 servo-thread
addf and2.3 servo-thread
addf and2.4 servo-thread
addf and2.5 servo-thread
addf left-z-pressed servo-thread
addf right-z-pressed servo-thread
addf cont-jog-scale servo-thread
addf decrease-z-speed servo-thread
addf slow-joy servo-thread
addf fast-joy servo-thread

##### Incremental jog is enabled by pressing X,Y,A, or B (which set the increment size), and the stick must be at the min/max to trigger a jog #####
# For incremental jog, joystick must be all the way to the min or max to trigger
setp near.0.in1 1
setp near.1.in1 1
setp near.2.in1 1
setp near.3.in1 -1
setp near.4.in1 -1
setp near.5.in1 -1

# near function should be a little forgiving
setp near.0.scale 1.03
setp near.1.scale 1.03
setp near.2.scale 1.03
setp near.3.scale 1.03
setp near.4.scale 1.03
setp near.5.scale 1.03

# set the size of incremental moves in units
setp mux8.0.in0 0  # this one must be 0 to prevent motion unless a button is pressed
setp mux8.0.in1 .005 #TODO set this to smallest movement increment
setp mux8.0.in2 .01
setp mux8.0.in3 .02
setp mux8.0.in4 .04
setp mux8.0.in5 0
setp mux8.0.in6 0
setp mux8.0.in7 0

# set incremental jog size
# Y or A
net btn-y or2.0.in0 <= input.0.btn-y
net btn-a or2.0.in1 <= input.0.btn-a
# A or B
net btn-a or2.1.in0
net btn-b or2.1.in1 <= input.0.btn-b
# setup the mux
net jog-size-0 mux8.0.sel0 <= or2.0.out 	# Y or A
net jog-size-1 mux8.0.sel1 <= or2.1.out 	# A or B
net btn-x mux8.0.sel2 <= input.0.btn-x		# X
# use mux to select increment size
net jog-size-final halui.jog.0.increment halui.jog.1.increment halui.jog.2.increment <= mux8.0.out

# move incremental if any of X,Y,A,B is pressed
net btn-a or2.2.in0
net btn-b or2.2.in1
net btn-x or2.3.in0
net btn-y or2.3.in1
net depressed-ab or2.4.in0 <= or2.2.out
net depressed-xy or2.4.in1 <= or2.3.out
# or2.4 is true if any of X,Y,A,B is pressed

# read joystick positions and check if near min or max
net joy-x-sig near.0.in2 near.3.in2 <= input.0.abs-rx-position
net joy-y-sig near.1.in2 near.4.in2 <= input.0.abs-ry-position
net joy-z-sig near.2.in2 near.5.in2 <= input.0.abs-y-position

# if joystick near min/max and X,Y,A, or B pressed, then send incremental jog
net jogincx and2.0.in0 <= near.0.out
net jogincy and2.1.in0 <= near.1.out
net jogincz and2.2.in0 <= near.2.out
net jogincxn and2.3.in0 <= near.3.out
net jogincyn and2.4.in0 <= near.4.out
net joginczn and2.5.in0 <= near.5.out

# and will be true if joystick near min/max and X,Y,A, or B pressed
net jog-inc-enable or2.4.out => and2.0.in1 and2.1.in1 and2.2.in1 and2.3.in1 and2.4.in1 and2.5.in1

# To change the direction of incremental move (e.g. if moves opposite to desired) just change the plus and minus portion of halui.jog.N.increment-(plus or minus)

# and2 outputs to halui incremental jog
net jogincx_final halui.jog.0.increment-plus <= and2.0.out
net jogincy_final halui.jog.1.increment-plus <= and2.1.out
net jogincz_final halui.jog.2.increment-plus <= and2.2.out
net jogincxn_final halui.jog.0.increment-minus <= and2.3.out
net jogincyn_final halui.jog.1.increment-minus <= and2.4.out
net joginczn_final halui.jog.2.increment-minus <= and2.5.out


##### Continuous jog #####
# mux between 0 and joystick
# mux's in0 is joystick position
net joy-x-sig => mux2.0.in0
net joy-y-sig => mux2.1.in0
net joy-z-sig => mux2.2.in0
# speed is 0 when using incremental jog
setp mux2.0.in1 0
setp mux2.1.in1 0
setp mux2.2.in1 0
# if X,Y,A, or B is pressed then mux outputs 0 speed
net jog-inc-enable mux2.0.sel mux2.1.sel mux2.2.sel

#TODO move Z to D pad, and XY to left joystick

# setup near to detect when L and R triggers are pressed (> 0)
# set L and R trigger to range [0,1]
setp input.0.abs-z-scale 255
setp input.0.abs-z-offset 0
setp input.0.abs-rz-scale 255
setp input.0.abs-rz-offset 0
# near is true when trigger is not pressed
setp near.7.in1 0
setp near.8.in1 0
net left-z-pos 	near.7.in2 <= input.0.abs-z-position
net right-z-pos	near.8.in2 <= input.0.abs-rz-position
# near function should be a little forgiving
setp near.7.difference .1
setp near.8.difference .1
# output of button-near-0 passes through not function to produce a 'pressed' signal
net left-z-zeroed 	near.7.out => left-z-pressed.in
net right-z-zeroed	near.8.out => right-z-pressed.in

# neither trigger pressed uses default value
# if left z is pressed then in1/in3 is chosen, if right z then in2
net m4s0 left-z-pressed.out 	=> mux4.0.sel0
net m4s1 right-z-pressed.out 	=> mux4.0.sel1

# feed position of L trigger through joyhandle. pos=0 -> gain=1. pos=1 -> gain=0
net left-z-pos => slow-joy.in
# a power of 1 makes it linear
# inverted = true means mirror around the y=x line
#power=4 invert=0 --> in=.5 out=.93
#power=4 invert=1 --> in=.5 out=.07
# increase power to make the trigger spend more time in the slower portions of its curve, i.e. more sensitive in the slow zone
setp slow-joy.power 3
setp slow-joy.offset 1
setp slow-joy.scale -1
setp slow-joy.inverse 1
# unset parameters
# joyhandle.N.deadband float rw (default: 0.)

# feed position of R trigger through joyhandle. pos=0 -> gain=1. pos=1 -> gain=4
#TODO fine tune fast speed
net right-z-pos => fast-joy.in
# increase power to make the trigger spend more time in the slower portions of its curve, i.e. more sensitive in the slow zone
setp fast-joy.power 2.5
setp fast-joy.offset 1
# this determines maximum speed of fast jog
setp fast-joy.scale 5
setp fast-joy.inverse 0

# neither trigger pressed means use default value - scale by 1
setp mux4.0.in0 1
net slow-gain mux4.0.in1 mux4.0.in3 <= slow-joy.out
net fast-gain mux4.0.in2 <= fast-joy.out

# this defines the default continuous jog speed
setp cont-jog-scale.in 100
# the L&R triggers determine the gain
net scale-gain cont-jog-scale.gain <= mux4.0.out
setp cont-jog-scale.offset 0
# gain * 100 IPM is max continuous jog speed (which is then multiplied by analog joystick value to get actual jog speed)
net jog-speed halui.jog-speed <= cont-jog-scale.out

# send continuous jog signal based on analog value of XY joystick
net joy-x-jog halui.jog.0.analog <= mux2.0.out
net joy-y-jog halui.jog.1.analog <= mux2.1.out
# set Z speed to half of XY speed
net zssi decrease-z-speed.in <= mux2.2.out
setp decrease-z-speed.gain .5
setp decrease-z-speed.offset 0
net joy-z-jog halui.jog.2.analog <= decrease-z-speed.out

# back button turns ESTOP on
net set-ESTOP input.0.btn-back 	=> halui.estop.activate
# start button unsets ESTOP (first press) and turns machine on (2nd press)
net unset-ESTOP input.0.btn-start => halui.estop.reset halui.machine.on

# TODO can use big central (mode) button for something

# LB unhomes selected axis
net unhome halui.joint.selected.unhome <= input.0.btn-tl
# RB homes selected axis
net home halui.joint.selected.home <= input.0.btn-tr

# XYB buttons select XYZ axes for homing purposes
net btn-x halui.joint.0.select
net btn-y halui.joint.1.select
net btn-b halui.joint.2.select

# TODO default jog speed is 0. left button goes from 0 to 50 but spends most of its time in the slow zone. right button starts at 50 and goes to 600 or so, spending more of its time in the slow zone.

#TODO incremental jog of 1 inch is pretty much worthless
